# Python笔记31--内置函数filter

### 描述

+ filter()函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。
+ 是一种高阶函数
+ 该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。

### 语法

```python
filter(function, iterable)
```

+ function : 函数

  第二个参数序列的每个元素作为参数传递给该函数进行判断，然后返回 True 或 False

  filter最后会将返回 True 的元素放到新列表或迭代器中。

+ iterable : 可迭代对象

+ 返回值

  + Python2.7 返回列表

  + Python3.x 返回迭代器对象

    `filter()`函数返回的是一个`Iterator`，也就是一个惰性序列，所以要强迫`filter()`完成计算结果，需要用`list()`函数获得所有结果并返回list。

### 实例：保留列表中的所有奇数，过滤所有偶数

```python
def is_odd(n):
    return n % 2 == 1
newlist = filter(is_odd, [1,2,3,4,5,6,7,8,9,10])
print(newlist)
for i in newlist:
    print(i)
```

```python
<filter object at 0x000001E336A06908>
1
3
5
7
9
```

### 实例：过滤出1-100中平方根是整数的数

```python
import math
def is_sqr(x):
    return math.sqrt(x) % 1 == 0
newlist = filter(is_sqr, (x for x in range(1,101)))
print(newlist)
for i in newlist:
    print(i)
```

```python
<filter object at 0x00000203090D6548>
1
4
9
16
25
36
49
64
81
100
```

### 实例：把一个序列中的空字符串删掉

```python
def isnull(s):
    return s and s.strip()

newli = list(filter(isnull, ['A', '', '  B', None, 'C', '  ']))
print(newli)
```

```python
['A', '  B', 'C']
```

+ filter只是过滤，不会改变原来list

### 实例：求素数

+ 使用埃氏筛法计算素数

  + 首先，列出从`2`开始的所有自然数，构造一个序列：

    2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...

  + 取序列的第一个数`2`，它一定是素数，然后用`2`把序列的`2`的倍数筛掉：

    3, ~~4~~, 5, ~~6~~, 7, ~~8~~, 9, ~~10~~, 11, ~~12~~, 13, ~~14~~, 15, ~~16~~, 17, ~~18~~, 19, ~~20~~, ...

  + 取新序列的第一个数`3`，它一定是素数，然后用`3`把序列的`3`的倍数筛掉：

    5, ~~6~~, 7, ~~8~~, ~~9~~, ~~10~~, 11, ~~12~~, 13, ~~14~~, ~~15~~, ~~16~~, 17, ~~18~~, 19, ~~20~~, ...

  + 取新序列的第一个数`5`，然后用`5`把序列的`5`的倍数筛掉：

    7, ~~8~~, ~~9~~, ~~10~~, 11, ~~12~~, 13, ~~14~~, ~~15~~, ~~16~~, 17, ~~18~~, 19, ~~20~~, ...

  + 不断筛下去，就可以得到所有的素数。

+ 实现

  + 构造一个从3开始的奇数序列

    ```python
    def _odd_iter():
        n = 1
        while True:
            n = n + 2
            yield n
    ```

    注意这是一个生成器，并且是一个无限序列。

  + 然后定义一个筛选函数

    ```python
    def _not_divisible(n):
        return lambda x: x % n > 0
    ```

  + 最后，定义一个生成器，不断返回下一个素数

    ```python
    def primes():
        yield 2
        it = _odd_iter() # 初始序列
        while True:
            n = next(it) # 返回序列的第一个数
            yield n
            it = filter(_not_divisible(n), it) # 构造新序列
    ```

  + 由于`primes()`也是一个无限序列，所以调用时需要设置一个退出循环的条件

    ```python
    # 打印1000以内的素数:
    for n in primes():
        if n < 1000:
            print(n)
        else:
            break
    ```

  + 注意到`Iterator`是惰性计算的序列，所以我们可以用Python表示“全体自然数”，“全体素数”这样的序列，而代码非常简洁。

### 实例：筛选出回数

+ 回数：数是指从左向右读和从右向左读都是一样的数

+ 实现

  ```python
  def is_palindrome(n):
      return str(n)==str(n)[::-1]
  
  output = filter(is_palindrome, range(1, 1000))
  print('1~1000:', list(output))
  if list(filter(is_palindrome, range(1, 200))) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191]:
      print('测试成功!')
  else:
      print('测试失败!')
  ```

  ```python
  1~1000: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515, 525, 535, 545, 555, 565, 575, 585, 595, 606, 616, 626, 636, 646, 656, 666, 676, 686, 696, 707, 717, 727, 737, 747, 757, 767, 777, 787, 797, 808, 818, 828, 838, 848, 858, 868, 878, 888, 898, 909, 919, 929, 939, 949, 959, 969, 979, 989, 999]
  测试成功!
  ```

+ 实现2

  将数字转化为每位数字的list，将list反转后比较是否相同来确定回文数的。有效但过于麻烦。