# Linux笔记46--Shell编程1-正则表达式

1. 正则表达式与通配符
   + 正则表达式用来==在文件中匹配符合条件的字符串==，正则是==包含匹配==。grep、awk、sed等命令可以支持正则表达式
   + 通配符用来匹配符合条件的==文件名==，通配符是==完全匹配==。ls、find、cp这些命令不支持正则表达式，所以只能用shell自己的通配符来进行匹配

2. 基础正则表达式

   | 元字符    | 作用                                                         |
   | --------- | ------------------------------------------------------------ |
   | *         | ==前==一个字符匹配0次或任意多次                              |
   | .         | 匹配除了换行符外任意一个字符                                 |
   | ^         | 匹配行首。如：^hello会匹配以hello开头的行                    |
   | $         | 匹配行尾。如：hello$会匹配以hello结尾的行                    |
   | []        | 匹配中括号中指定的任意一个字符，只匹配一个字符。如：[aoeiu]匹配任意一个元音字母，[0-9]匹配任意一位数字   ==有且只有一个==    ==不匹配换行符== |
   | [^]       | 匹配除了中括号中的字符以外的任意一个字符                     |
   | \         | 转义符。用于取消特殊符号的含义                               |
   | \\{n\\}   | 表示起前面的字符恰好出现n次。如：[0-9]\\{4\\}表示匹配四位数字，\[1]\[3-8][0-9]\\{9\\}匹配手机号码  （\其实是{和}的转义符） |
   | \\{n,\\}  | 表示其前面的字符出现不小于n次。如：[0-9]\\{2,\\}表示两位及以上的数字 |
   | \\{n,m\\} | 表示其前面的字符至少出现n次，最多出现m次。如：[a-z]\\{6,8\\}匹配6到8位的小写字母 |

   + 例1：grep "a*" test             #匹配所有内容，包括空白行
   + 例2：grep "aa*" test           #匹配至少包含有一个a的行

   ---

   + 例3：grep "s.*d" test          #匹配在s和d字母之间有零个或任意多个字符    

     ​                                               #==在正则表达式中 “.\*“ 相当于通配符中的 \*==

   + 例4：grep ".*"                      #匹配所有内容

   ---

   + 例5：grep -n "^$" test         #==匹配空白行==，并列出行号

   ---

   + 例6：grep "\\.$" test             #匹配以“.”结尾的行
   + 例7：grep ".$" test              #匹配除了空白行以外的所有行

   ---

   + grep "^[0-9]\\{3,\\}[a-z]"        #匹配最少用连续三个数字开头的行