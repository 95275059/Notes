# Algorithm5--子数组问题

## 128.最长连续序列

### 题目

给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 O(n) 的算法解决此问题。

### 示例：

输入：nums = [100,4,200,1,3,2]；输出：4；解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
输入：nums = [0,3,7,2,5,8,4,6,0,1]；输出：9

### 解题思路：哈希表

* 我们考虑枚举数组中的每个数 x，考虑以其为起点，不断尝试匹配 x+1, x+2,⋯ 是否存在，
* 假设最长匹配到了 x+y，那么以 x 为起点的最长连续序列即为 x, x+1, x+2,⋯,x+y，其长度为 y+1，我们不断枚举并更新答案即可。
* 对于匹配的过程，暴力的方法是 O(n) 遍历数组去看是否存在这个数，但其实更高效的方法是用一个哈希表存储数组中的数，这样查看一个数是否存在即能优化至 O(1) 的时间复杂度。
* 仅仅是这样我们的算法时间复杂度最坏情况下还是会达到 O(n^2)（即外层需要枚举 O(n) 个数，内层需要暴力匹配 O(n) 次），无法满足题目的要求。
* 但仔细分析这个过程，我们会发现其中执行了很多不必要的枚举，如果已知有一个 x, x+1, x+2,⋯,x+y 的连续序列，而我们却重新从 x+1，x+2 或者是 x+y 处开始尝试匹配，那么得到的结果肯定不会优于枚举 x 为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可。
* 那么怎么判断是否跳过呢？
* 由于我们要枚举的数 x 一定是在数组中不存在前驱数 x−1 的，不然按照上面的分析我们会从 x−1 开始尝试匹配，
* 因此我们每次在哈希表中检查是否存在 x−1 即能判断是否需要跳过了。

### 代码

```python
class Solution:
    def longestConsecutive(self, nums):
        # 时间击败79.78%，内存击败38.54%
        result = 0
        num_set = set(nums)
        for num in num_set:
            if num - 1 not in num_set:
                current_num = num
                while current_num + 1 in num_set:
                    current_num += 1
                result = max(result, current_num - num + 1)
        return result
```

## 300.最长递增子序列

### 题目

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。
例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

### 示例

输入：nums = [10,9,2,5,3,7,101,18]；输出：4；解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
输入：nums = [0,1,0,3,2,3]；输出：4
输入：nums = [7,7,7,7,7,7,7]；输出：1

### 解题思路：动态规划

* 定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取。

* 我们从小到大计算 dp 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0…i−1] 的值，则状态转移方程为：

  dp[i]=max(dp[j])+1,其中0≤j<i且num[j]<num[i]

* 即考虑往 dp[0…i−1] 中最长的上升子序列后面再加一个 nums[i]。
* 由于 dp[j] 代表 nums[0…j] 中以 nums[j] 结尾的最长上升子序列，所以如果能从 dp[j] 这个状态转移过来，那么 nums[i] 必然要大于 nums[j]，才能将 nums[i] 放在 nums[j] 后面以形成更长的上升子序列。
* 最后，整个数组的最长上升子序列即所有 dp[i] 中的最大值。
  LISlength=max(dp[i]),其中0≤i<n

### 代码

```python
class Solution(object):
    def lengthOfLIS(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        时间击败57.14%，内存击败72.19%
        """
        if not nums:
            return 0
        length = len(nums)
        dp = []
        for i in range(length):
            dp.append(1)
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
```

## 674.最长连续递增序列

### 题目

给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。
连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

### 示例

输入：nums = [1,3,5,4,7]；输出：3；解释：最长连续递增序列是 [1,3,5], 长度为3。
输入：nums = [2,2,2,2,2]；输出：1；解释：最长连续递增序列是 [2], 长度为1。

### 解题思路：贪心

* 对于下标范围 [l,r] 的连续子序列，如果对任意 l≤i]<nums[i+1]，则该连续子序列是递增序列。
* 假设数组 nums 的长度是 n，对于 l≤r<n−1，如果下标范围 [l,r] 的连续子序列是递增序列，则考虑 nums[l−1] 和 nums[r+1]。
  * 如果 nums[l−1]<nums[l]，则将 nums[l−1] 加到 nums[l] 的前面，可以得到更长的连续递增序列.
  * 如果 nums[r+1]>nums[r]，则将 nums[r+1] 加到 nums[r] 的后面，可以得到更长的连续递增序列。
* 基于上述分析可知，为了得到最长连续递增序列，可以使用贪心的策略得到尽可能长的连续递增序列。
* 做法是使用记录当前连续递增序列的开始下标和结束下标，遍历数组的过程中每次比较相邻元素，根据相邻元素的大小关系决定是否需要更新连续递增序列的开始下标。
* 具体而言，令 start 表示连续递增序列的开始下标，初始时 start=0，然后遍历数组 nums，进行如下操作。
  * 如果下标 i>0 且 nums[i]≤nums[i−1]，则说明当前元素小于或等于上一个元素，因此 nums[i−1] 和 nums[i] 不可能属于同一个连续递增序列，必须从下标 i 处开始一个新的连续递增序列，因此令 start=i。
  * 如果下标 i=0 或 nums[i]>nums[i−1]，则不更新 start 的值。
  * 此时下标范围 [start,i] 的连续子序列是递增序列，其长度为 i−start+1，使用当前连续递增序列的长度更新最长连续递增序列的长度。
  * 遍历结束之后，即可得到整个数组的最长连续递增序列的长度。

### 代码

```python
class Solution(object):
    def findLengthOfLCIS(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        时间击败59.50%，内存击败68.18%
        """
        if not nums:
            return 0
        length = len(nums)
        result, start = 0, 0
        for i in range(length):
            if i > 0 and nums[i] <= nums[i-1]:
                start = i
            result = max(result, i - start + 1)
        return result
```

